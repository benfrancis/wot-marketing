---
layout: default
title: W3C WoT – Explainer
group: "navigation"
---
<div>
<h2>WoT Thing Description (TD) 1.1 Explainer</h2>

<p>
This is an updated version of the [Explainer for TD 1.0](Explainer.md).
<mark>DP: Still needed?</mark>
</p>

<h3>What's All This About?</h3>

<!--
[//]: # (What role does the TD specification play in the WoT?)

[//]: # (A brief, 4-5 paragraph explanation of the feature’s value. Outline what the feature does and how it accomplishes those goals in prose. If your feature creates UI, this is a great place to show mocks and user flows.)

[//]: # (The W3C Web of Things [WoT] is intended to enable
interoperability across IoT Platforms and application domains using Web technology.)
-->

<p>
In the [WoT Architecture](https://w3c.github.io/wot-architecture/index.html), 
a Thing is defined as an abstraction of a physical IoT device such as a sensor (temperature, CO2, ...), an actuator (lamp, motor, ...), or a virtual entity (e.g., composition of one or more Things, weather service). The Thing Description (TD) provides descriptive metadata for a Thing's network interface.
</p>

<p>
With a TD, clients are informed of the choices they can make when interacting with Things such reading a temperature value or switching on a lamp. This can drive applications in the same way that Web HTML pages allow users to
make choices when navigating the Web and drive Web applications
through links and forms. Therefore, the TD can be also seen as the ‘index.html’ for Things. The TD itself is serialized in JSON-LD 1.1. 
</p>

<p>
TDs are designed to provide all the information needed to interact with a Thing. Specifically, it provides answers to questions like those shown in the following figure.
</p>

<p><img src="images/explainer_td.png" class="img-responsive" alt="How to Interact with IoT Devices"></p>

<h3>Getting started</h3>

<p>
Let us assume there is a smart lamp that offers an interface with following characteristics:
</p>

<style>
table, th, td {
  border: 1px solid;
  border-collapse: collapse;
}
th, td {
  padding: 5px;
}
tr:nth-child(even) {
  background-color: #D3D3D3; /*LightGray*/
}
</style>

<table>
<tbody>
	<tr>
		<th>Name</th>
		<th>MyLampThing</th>
		<th></th>
	</tr>
	<tr>
		<td>Protocol</td>
		<td>HTTPS</td>
		<td></td>
	</tr>
	<tr>
		<td>Security</td>
		<td>Basic authentication</td>
		<td></td>
	</tr>
	<tr>
		<td>Local server address</td>
		<td>192.168.2.134</td>
		<td></td>
	</tr>
	<tr>
		<td>Content type</td>
		<td>application/json</td>
		<td></td>
	</tr>
	<tr>
		<td>Data / function offerings:</td>
		<td>status (type: string)</td>
		<td>Resource (GET): /status</td>
	</tr>
	<tr>
		<td></td>
		<td>toggle</td>
		<td>Resource (POST): /toggle</td>
	</tr>
	<tr>
		<td></td>
		<td>overheating (type: string)</td>
		<td>Resource (GET &amp; longpoll): /oh</td>
	</tr>
</tbody>
</table>

<br />
<p>
Based on such information a Thing Description can be designed in the following way
</p>

<code><pre>
{
    "@context": "https://www.w3.org/2022/wot/td/v1.1",
    "title": "MyLampThing",
    "securityDefinitions": {
        "basic_sc": {"scheme": "basic", "in": "header"}
    },
    "security": "basic_sc",
    "properties": {
        "status": {
            "type": "string",
            "forms": [{"href": "https://192.168.2.134/status"}]
        }
    },
    "actions": {
        "toggle": {
            "forms": [{"href": "https://192.168.2.134/toggle"}]
        }
    },
    "events":{
        "overheating":{
            "data": {"type": "string"},
            "forms": [{
                "href": "https://192.168.2.134/oh",
                "subprotocol": "longpoll"
            }]
        }
    }
}
</pre></code>

<p>
Before going into detail an important paradigm is explained that is defined by the <a href="https://w3c.github.io/wot-architecture/index.html" target="_blank">WoT Architecture</a>, namely about the interaction affordances <strong>properties</strong>, <strong>actions</strong>, and <strong>events</strong>. 
</p>

<p>
Each Thing and its data and functions offerings that is possible via the interface can be classified in those affordances. Sensor and/or parameter data are considered <strong>properties</strong>. Functions like on/off, dimming, etc. are considered <strong>actions</strong>. Notifications and data streams are considered <strong>events</strong>. 
</p>

<p>
In this context, the MyLampThing example above would result in declaring <code>status</code> a property, <code>toggling</code> an action, and <code>overheating</code> an event. 
</p>

<p>
Now, by processing the above example TD,  a client can obtain knowledge about the Thing named <code>MyLampThing</code>, including the following:
</p>

<ul>
<li>
  The Thing requires the use of HTTP Basic Authentication when 
  accessing all interaction resources (announced by securityDefinitions and security).
</li>
<li>
  The Thing provides one Property interaction resource with the name <code>status</code>.
  <ul>
  <li>
    The property > is accessible via the HTTP protocol
    with a GET method at URI <code>https://192.168.2.134/status</code>.
  </li>
  <li>
    Reading the property <code>status</code> will return a string value.
  </li>
  </ul>
</li>
<li>
  The Thing provides one Action interaction resource with the name <code>toggle</code>. 
  <ul><li>
    The action <code>toggle</code> is accessible via the HTTP protocol
    with a POST method at URI <code>https://192.168.2.134/toggle</code>.
  </li></ul>
</li>
<li>
  The Thing provides one Event interaction resource with the name <code>overheating</code>.
  <ul>
  <li>
    The event <code>overheating</code> can be obtained at URI 
    <code>https://192.168.2.134/oh</code> by using HTTP with a long polling subprotocol.
    The subprotocol clarifies which of several possible mechanisms in HTTP
    are used to provide "push" notifications.
  </li>
  <li>
    Each message pushed by the Thing is a string value.
  </li>
  </ul>
</li>
</ul>


<h3>What can you do with a Thing Description (TD)?</h3>

<p>
Based on the information in a TD, a WoT software stack such as that described in the <a href="https://w3c.github.io/wot-scripting-api/" target="_blank">W3C Web of Things Scripting API</a> can interpret the TD content and automatically handle all the communication details. A developer working with the <strong>properties</strong>, <strong>actions</strong>, and <strong>events</strong> affordances does not need to deal with protocol specific details such as the HTTP method, the resource address, port number, etc.. The following video gives an insight about this aspect:
</p>

<p><a href="http://www.youtube.com/watch?v=lt_P2BU8e3I" target="_blank" title="TD usage with a programming API"><img src="http://img.youtube.com/vi/lt_P2BU8e3I/0.jpg" alt="TD usage with a programming API"></a></p>

<p>
This example also shows that TDs can be used to onboard Things into an IoT ecosystem (e.g., IoT cloud services, edge systems, etc.). TD helps a client to understand what the Things offers and how the offered data and functions can be bound to application processes (e.g., creating service mash-ups, dashboards, etc.). The following example shows how a TD is used in a Node-RED application:
</p>

<p><a href="http://www.youtube.com/watch?v=oAcYbJ6P9bU" target="_blank" title="TD usage in Node-RED"><img src="http://img.youtube.com/vi/oAcYbJ6P9bU/0.jpg" alt="TD usage in Node-RED"></a></p>

<p>
TD also helps to manage IoT systems. An IoT system typically consists of a heterogenous set of devices provided by different vendors and based on different technologies and protocols (e.g. HTTP, MQTT, Modbus, etc). Directories can be used to manage the TDs (e.g., create, search, etc). <a href="https://w3c.github.io/wot-discovery/" target="_blank">The W3C WoT Discovery</a> defines mechanisms for controlled distribution and access to TDs, including searchable directories in which TDs can be dynamically registered. 
</p>

<h3>What Other Features Support the Thing Description Specification?</h3>
<p>
Other features complementary to the TD, including Protocol Bindings, Context Extensions, and Thing Models, support and extend its functionality.
</p>

<h4>Protocol Binding</h4>
<p>
A Thing Description is not limited to HTTP based interfaces as shown in the example above. In general, WoT is a protocol agnostic approach and provides a common mechanism to define how specific protocols such as MQTT, HTTP, CoAP or Modbus can be mapped to the WoT’s interaction properties-action-event abstraction within the Thing Description <code>forms</code> definition. More details is provide in the <a href="https://w3c.github.io/wot-thing-description/#protocol-bindings" target="_blank">Protocol Binding section</a>.  
</p>

<h4>TD Context Extensions</h4>
<p>
Through JSON-LD serialization, the WoT Thing Description provides the ability to add vocabulary and concepts defined in additional namespaces. This mechanism can be used to enrich the Thing Description instances with additional (e.g., domain-specific) semantics. It can also be used to import additional Protocol Bindings or new security schemes. 
</p>
<p>
 The following TD extends the TD above by introducing a second definition in the <code>@context</code> to declare the prefix <code>saref</code> as referring to SAREF. This IoT ontology includes terms interpreted as semantic labels that can be set as values of the <code>@type</code> field, giving the semantics of Things and their interaction affordances. In the example below, the Thing is labelled with <code>saref:LightSwitch</code>, the status Property is labelled with <code>saref:OnOffState</code> and the toggle Action with <code>saref:ToggleCommand</code>.
</p>

<code><pre>
{
    "@context": [
        "https://www.w3.org/2022/wot/td/v1.1",
        { "saref": "https://w3id.org/saref#" }
    ],
    "title": "MyLampThing",
    "@type": "saref:LightSwitch",
    "securityDefinitions": {
        "basic_sc": {"scheme": "basic", "in": "header"}
    },
    "security": "basic_sc",
    "properties": {
        "status": {
            "@type": "saref:OnOffState",
            "type": "string",
            "forms": [{
                "href": "https://192.168.2.134/status"
            }]
        }
    },
    "actions": {
        "toggle": {
            "@type": "saref:ToggleCommand",
            "forms": [{
                "href": "https://192.168.2.134/toggle"
            }]
        }
    },
    "events": {
        "overheating": {
            "data": {"type": "string"},
            "forms": [{
                "href": "https://192.168.2.134/oh"
            }]
        }
    }
}
</pre></code>

<h4>Thing Model definition</h4>
<p>
One of the main intentions of a Thing Description is to provide a client with all the details necessary to successfully interact with a Thing. In some IoT application scenarios, a fully detailed Thing Description, e.g., with communication metadata is not necessary (e.g., some IoT ecosystems may implicitly handle communication separately), or may not be available because a new entity has not yet been deployed (e.g., IP address is not yet known). Sometimes, also a kind of class definition is required that provides capability definitions that should be available for all created instances (e.g., large-scale production of new devices).
</p>
<p>
In order to address the above-mentioned scenarios or others, the Thing Model can be used that mainly provides the data model definitions within Things' Properties, Actions, and/or Events and can be potentially used as template for creating Thing Description instances. In the following a sample Thing Model is presented that can be seen as a model for the Thing Description instance in the first TD example above.
</p>

<code><pre>
{
    "@context": ["https://www.w3.org/2022/wot/td/v1.1"], 
    "@type" : "tm:ThingModel",
    "title": "Lamp Thing Model",
    "properties": {
        "status": {
            "description": "current status of the lamp (on|off)",
            "type": "string",
            "readOnly": true
        }
    },
    "actions": {
        "toggle": {
            "description": "Turn the lamp on or off"
        }
    },
    "events": {
        "overheating": {
            "description": "Lamp reaches a critical temperature (overheating)",
            "data": {"type": "string"}
        }
    }
}
</pre></code>

<p>
Thing Model definitions are identified by the <code>@type: tm:ThingModel</code>. As the example shows, it does not provide details about a single Thing instance due to the lack of communication and security metadata. This specification presents a mechanism for deriving valid Thing Description instances from such Thing Model definitions. In addition, other design concepts are specified, including how to override, extend, and reuse existing Thing Model definitions. 
</p>


<h3>Non-Goals of Thing Description (TD)</h3>

<p>
The following are explictly NOT goals of the TD specification:
</p>
<ul>
<li>
  Application- and domain-specific metadata vocabularies.
  <ul><li>
     TDs support the use of domain-specific vocabularies,
     but no domain-specific vocabularies are defined as part of the specification.
  </li></ul>
</li>
<li>
  Modification of existing protocols or security mechanisms.
</li>
<li>
  Specifications of new protocols or security mechanisms.
  <ul><li>
     TDs are meant to describe existing practice, not prescribe new practices.
  </li></ul>
</li>
</ul>
<p>
TDs are also limited to protocols that have resources and access points that can
be described with URLs and to payload types that have an IANA media Type.
Structured payloads are supported but should be
conceptually interconvertible with JSON.
</p>

<h3>Differentiation to Thing Description 1.0 and Backward Compatibility</h3>
The main difference of this new specification from Thing Description 1.0 is that it includes the Thing Model concept (see above). This was only discussed in the Annex of the Thing Description 1.0 and was called Thing Description Template at that time. 

A new features is also possible to indicate that a Thing is following a specific profile such as the <a href="https://w3c.github.io/wot-profile/" target="_blank">W3C WoT Core Profile</a>. 

In general, TD 1.1 is backward compatible with implementations that follow version TD 1.0.  

The new minor version update is also used to redefine some features more clearly and to add additional examples to make it easier to understand. 

The complete change log with the new features and refinements can be found in the <a href="https://w3c.github.io/wot-thing-description/#changes" target="_blank">change log section</a>. 




<h3>Implementations</h3>

Implementations were built, among others, by Bosch, Smart Things, ERCIM, Hitachi, Intel, Oracle, Panasonic, Fujitsu, ECHONET, NHK, and Siemens.
The latest list of implementations can be found in the <a href="https://w3c.github.io/wot-thing-description/testing/report11.html" target="_blank">implementation report</a> or in the <a href="{{'developers/' | relative_url }}">developer space</a> at the W3C WoT main page. 

<h3>Related Work</h3>
<p>
There are already several interface description languages on the market.
However, most of them do not focus on IoT use cases and do not support IoT-based protocols such as MQTT, CoAP and Modbus, or some are also very specific to a particular application domain. 
In addition, the alignment of a semantic approach (e.g., based on RDF) is also missing to
enable the reuse of existing domain usages to increase interoperability
in IoT scenarios. In the following, well-known description languages are listed:
</p>

<ul>
<li>
  WSDL: Around 15 years ago, <a href="https://www.w3.org/TR/wsdl20/" target="_blank">WSDL</a> 
  was quite popular to describe SOAP based web services and to realize
  SOA-based architectures.
  One of the strength (however, which is also a weakness),
  is the rich set of WS-* add-ons such as for semantic, security,
  and notification mechanisms.
  The data model that can be exchanged between server and client
  can be designed via XML Schema definitions.
  Today, WSDL is no longer a preferred technology.
  One of the reasons is the complex implementation of WSDL based web services
  (especially on the client side),
  the limitation to SOAP/XML messaging and the usage of HTTP protocol only.
  In addition, the huge WS-* opportunities,
  which contain redundant concepts, often led to incompatible implementations.
  Another downside is that there is a huge effort when the content of the
  WSDL is slightly changed.
  All client implementations (typically stubs and skeletons) have to be
  newly generated and compiled.
</li>
<li>
  OpenAPI/SWAGGER: <a href="https://swagger.io/" target="_blank">OpenAPI</a> specification is one of
  the most popular web interface descriptions on the market.
  Mainly, this solution is used to describe REST/HTTP based APIs interfaces
  with JSON messaging.
  JSON Schema is used to describe the data model.
  OpenAPI has a huge community and provides a rich set of tools and libraries
  for different kinds of platforms.
  One of drawbacks of OpenAPI is the non-support of standard semantic annotations
  and the (re-)usage of domain knowledge (e.g., iotschema.org).
  Interface descriptions via OpenAPI are mainly designed for humans and have to
  interpreted by humans (if possible).
  Machine interpretation and a semantic-based discovery/querying are out of scope.
  Another drawback is the limitation to HTTP protocols.
  MQTT, CoAP, OPC UA etc. are not covered.
</li>
<li>
  RAML: The purpose of the RESTful API Modeling Language (<a href="https://raml.org/" target="_blank">RAML</a>)
  is very similar to that of OpenAPI,
  as it is mainly intended to develop REST/HTTP-based APIs.
  In contrast to OpenAPI,
  RAML offers more flexibility in terms of including and reusage of external code
  and schema definitions such as XML Schema.
  Similar to OpenAPI,
  there is a lack of standardized semantic support without a query/discovery mechanism
  as well as the limitation to the HTTP protocol.
</li>
<li>
Electronic Device Description Language (EDDL): EDDL is an IEC standard (<a href="https://webstore.iec.ch/publication/60628" target="_blank">IEC 61804-3</a>) for describing the communication characteristics of the field devices and its parameters such as device status, diagnostic data, and configuration details for an operating system and human machine
interface (HMI) environment. Initially EDDL was developed in 1992 for use as part of the HART Communication Protocol and was adopted into the Foundation fieldbus and Profibus standards in 1994. Today, EDDL is mainly used in the process automation domain with appropriate tools to generate an interpretative code to support parameter handling, operation, and monitoring of automation system components (e.g., remote I/Os, controllers, sensors).
</ul>

</div>
